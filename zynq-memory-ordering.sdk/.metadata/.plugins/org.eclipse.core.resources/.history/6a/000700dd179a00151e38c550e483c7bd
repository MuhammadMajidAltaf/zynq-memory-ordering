/*
 * commandline.c
 *
 *  Created on: Dec 3, 2015
 *      Author: scdl
 */

#include "constant_definitions.h"
#include "FreeRTOS_CLI.h"

#define HELP_CMD_PARAM_BOOL		"  [bool] Must either be 0 or 1."
#define HELP_CMD_PARAM_HA		"  [ha] Must be one of the following string of characters: ha_acp_0, ha_acp_1, ha_gp0_0, ha_hp0_0, ha_hp1_0, ha_hp2_0."
#define HELP_CMD_PARAM_LEN		"  [len] Must inclusively range from 2 to 256, in steps of power of 2."
#define HELP_CMD_PARAM_SIZE		"  [size] Must be greater than 0 and a multiple of the burst length multiplied by the AXI data width in bytes."
#define HELP_CMD_PARAM_OP_MOD 	"  [op_mod] Must be one of the following string of characters: separate, mixed, fully_mixed."
#define HELP_CMD_PARAM_MEM		"  [mem] Must be one of the following string of characters: ocm, ddr. "
#define HELP_CMD_PARAM_CACHE	"  [cache] Must be one of the following string of characters: so, sd, wt_nwa, wb_wa, wb_nwa, nc."
#define HELP_CMD_PARAM_ID		"  [id] Must be a value greater than 0."
#define HELP_CMD_PARAM_LOC		"  [loc] Must be a value greater than 0."
#define HELP_CMD_PARAM_DUM		"  [dum] Must be one of the following string of characters: dummy_0"

/********************** Globals (User Defined) ***********************/

static 	struct {
			int is_json:1;						/**< Flag indicating whether JSON-encoding is enabled. */
			int configure_cpu1_flag:1;			/**< Flag indicating whether commands are forwarded to the second cpu. */
			int capture_write_to_buffer_flag:1;	/**< Flag indicating whether the write commands buffer data instead of forwarding to virtual console. */
		} 									status_obj;
extern	int									pcEchoFlag;							/**< Toggles echoing with the console. */
extern 	int									pcCmdCharsFlag;						/**< Toggles extra character strings generated by the console. */

/*************** Function Prototypes (User Defined) ******************/

static 	portBASE_TYPE	set_json_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static	portBASE_TYPE	set_configure_cpu1_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static	portBASE_TYPE	set_configure_smp_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	request_operation_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_enable_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_location_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_params_burst_len_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_params_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_params_params_operation_mode_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_params_memory_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_hardware_cache_coherent_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static	portBASE_TYPE	get_hardware_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_memory_policies_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_memory_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	get_memory_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	get_hard_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static	portBASE_TYPE	get_synch_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_enable_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_identifier_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_location_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_powersave_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_params_burst_len_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_params_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_params_operation_mode_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	portBASE_TYPE	set_dummy_task_params_memory_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static	portBASE_TYPE	get_dummy_task_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString);
static 	char* 			get_parameter(const char *pcCommandString, int parameter_position);
static 	int 			is_integer(char* nullTerminatedString);
static 	void 			set_status(char* pcWriteBuffer,size_t xWriteBufferLen,int is_success_flag);

extern void vUARTCommandConsoleStart( uint16_t usStackSize, UBaseType_t uxPriority );
extern int main_request_operation();

/**************** Type Definitions (User Defined) ********************/

static const CLI_Command_Definition_t set_json_struct = {
	"set_json",
	"\r\nset_json [bool]\r\n"
	" Sets the output to pretty-print or JavaScript Object Notation (JSON).\r\n"
	HELP_CMD_PARAM_BOOL " 0 indicates pretty-print is active, whereas 1 indicates JSON-encoding is active.\r\n"
	"\r\n",
	set_json_func,
	1
};

static const CLI_Command_Definition_t set_configure_cpu1_struct = {
	"set_configure_cpu1",
	"\r\nset_configure_cpu1 [bool]\r\n"
	" Sets the flag indicating whether or not certain commands are forwarded to the virtual command line of cpu 1.\r\n"
	HELP_CMD_PARAM_BOOL " 0 indicates cpu 0 is configurable, whereas 1 indicates some commands are forwarded to cpu 1.\r\n"
	"\r\n",
	set_configure_cpu1_func,
	1
};

static const CLI_Command_Definition_t set_configure_smp_struct = {
	"set_configure_smp",
	"\r\nset_configure_smp [bool]\r\n"
	" Sets the symmetric multiprocessing (SMP) bit.\r\n"
	HELP_CMD_PARAM_BOOL " 0 indicates indicates SMP bit is low, whereas 1 indicates SMP bit is high.\r\n"
	"\r\n",
	set_configure_smp_func,
	1
};

static const CLI_Command_Definition_t request_opteration_struct = {
	"request_operation",
	"\r\nrequest_operation\r\n"
	" Starts the operation, but only when at least one hardware accelerator is enabled.\r\n"
	"\r\n",
	request_operation_func,
	0
};

static const CLI_Command_Definition_t set_hardware_enable_struct = {
	"set_hardware_enable",
	"\r\nset_hardware_enable [ha] [bool]\r\n"
	" Sets the enable for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is a boolean value that specifies the enable state.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_BOOL "\r\n"
	"\r\n",
	set_hardware_enable_func,
	2
};

static const CLI_Command_Definition_t set_hardware_location_struct = {
	"set_hardware_location",
	"\r\nset_hardware_location [ha] [loc]\r\n"
	" Sets the location for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is an integer value that specifies the location.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_LOC "\r\n"
	"\r\n",
	set_hardware_location_func,
	2
};

static const CLI_Command_Definition_t set_hardware_params_burst_len_struct = {
	"set_hardware_params_burst_len",
	"\r\nset_hardware_params_burst_len [ha] [len]\r\n"
	" Sets the burst length for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is the burst length.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_LEN "\r\n"
	"\r\n",
	set_hardware_params_burst_len_func,
	2
};

static const CLI_Command_Definition_t set_hardware_params_transfer_size_struct = {
	"set_hardware_params_transfer_size",
	"\r\nset_hardware_params_transfer_size [ha] [size]\r\n"
	" Sets the transfer size for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is the transfer size.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_SIZE "\r\n"
	"\r\n",
	set_hardware_params_transfer_size_func,
	2
};

static const CLI_Command_Definition_t set_hardware_params_operation_mode_struct = {
	"set_hardware_params_operation_mode",
	"\r\nset_hardware_params_operation_mode [ha] [op_mod]\r\n"
	" Sets the operation mode for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is string that specifies the operation mode.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_OP_MOD "\r\n"
	"\r\n",
	set_hardware_params_params_operation_mode_func,
	2
};

static const CLI_Command_Definition_t set_hardware_params_memory_struct = {
	"set_hardware_params_memory",
	"\r\nset_hardware_params_memory [ha] [mem]\r\n"
	" Sets the memory for a specified hardware accelerator.\n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is string that specifies the memory.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_MEM "\r\n"
	"\r\n",
	set_hardware_params_memory_func,
	2
};

static const CLI_Command_Definition_t set_hardware_cache_coherent_struct = {
	"set_hardware_cache_coherent",
	"\r\nset_hardware_cache_coherent [ha] [bool]\r\n"
	" Sets the cache coherent for a specified hardware accelerator. Cache coherency is only available to the ACP. \n\r"
	" The first argument is string that specifies the hardware accelerator, whereas the second is a boolean value that specifies the enable state.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	HELP_CMD_PARAM_BOOL "\r\n"
	"\r\n",
	set_hardware_cache_coherent_func,
	2
};

static const CLI_Command_Definition_t get_hardware_report_struct = {
	"get_hardware_report",
	"\r\nget_hardware_report [ha]\r\n"
	" Gets the report for a specified hardware accelerator.\n\r"
	" The argument is string that specifies the hardware accelerator.\r\n"
	HELP_CMD_PARAM_HA "\r\n"
	"\r\n",
	get_hardware_report_func,
	1
};

static const CLI_Command_Definition_t set_memory_policies_struct = {
	"set_memory_policies",
	"\r\nset_memory_policies [mem] [cache] [cache]\r\n"
	" Sets the cache policies for a specified memory.\n\r"
	" The first argument is string that specifies the memory, whereas the next two string arguments respectively specify the L1 and L2 cache policies.\r\n"
	HELP_CMD_PARAM_MEM "\r\n"
	HELP_CMD_PARAM_CACHE "\r\n"
	HELP_CMD_PARAM_CACHE "\r\n"
	"\r\n",
	set_memory_policies_func,
	3
};

static const CLI_Command_Definition_t set_memory_transfer_size_struct = {
	"set_memory_transfer_size",
	"\r\nset_memory_transfer_size [mem] [size]\r\n"
	" Sets the maximum transfer size of a specified memory.\n\r"
	" The first argument is string that specifies the memory, whereas the next is the transfer size.\r\n"
	HELP_CMD_PARAM_MEM "\r\n"
	HELP_CMD_PARAM_SIZE "\r\n"
	"\r\n",
	set_memory_transfer_size_func,
	2
};

static const CLI_Command_Definition_t get_memory_report_struct = {
	"get_memory_report",
	"\r\nget_memory_report [mem]\r\n"
	" Gets the report for a specified memory.\n\r"
	" The argument is string that specifies the memory.\r\n"
	HELP_CMD_PARAM_MEM "\r\n"
	"\r\n",
	get_memory_report_func,
	1
};

static const CLI_Command_Definition_t get_hard_report_struct = {
	"get_hard_report",
	"\r\nget_hard_report\r\n"
	" Returns a report with the hard coded configurations, including clock speeds (not implemented).\n\r"
	"\r\n",
	get_hard_report_func,
	0
};

static const CLI_Command_Definition_t get_synch_report_struct = {
	"get_synch_report",
	"\r\nget_synch_report\r\n"
	" Gets the synch report.\n\r"
	"\r\n",
	get_synch_report_func,
	0
};

static const CLI_Command_Definition_t set_dummy_task_enable_struct = {
	"set_dummy_task_enable",
	"\r\nset_dummy_task_enable [dum] [bool]\r\n"
	" Sets the enable for the dummy task.\n\r"
	" The only argument is a boolean value that specifies the enable state.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_BOOL "\r\n"
	"\r\n",
	set_dummy_task_enable_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_identifier_struct = {
	"set_dummy_task_identifier",
	"\r\nset_dummy_task_identifier [dum] [id]\r\n"
	" Sets the identifier of the dummy task.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a value that specifies the identifier.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_ID "\r\n"
	"\r\n",
	set_dummy_task_identifier_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_location_struct = {
	"set_dummy_task_location",
	"\r\nset_dummy_task_location [dum] [loc]\r\n"
	" Sets the location of the dummy task.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a value that specifies the location.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_LOC "\r\n"
	"\r\n",
	set_dummy_task_location_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_powersave_struct = {
	"set_dummy_task_powersave",
	"\r\nset_dummy_task_powersave [dum] [bool]\r\n"
	" Sets whether the dummy task launches in powersave mode.\n\r"
	" The only argument is a boolean value that specifies the powersave state.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_BOOL "\r\n"
	"\r\n",
	set_dummy_task_powersave_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_params_burst_len_struct = {
	"set_dummy_task_params_burst_len",
	"\r\nset_dummy_task_params_burst_len [dum] [len]\r\n"
	" Sets the burst length of the dummy task in words.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a value that specifies the burst length.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_LEN "\r\n"
	"\r\n",
	set_dummy_task_params_burst_len_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_params_transfer_size_struct = {
	"set_dummy_task_params_transfer_size",
	"\r\nset_dummy_task_params_transfer_size [dum] [size]\r\n"
	" Sets the transfer size of the dummy task in bytes.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a value that specifies the transfer size.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_SIZE "\r\n"
	"\r\n",
	set_dummy_task_params_transfer_size_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_params_operation_mode_struct = {
	"set_dummy_task_params_operation_mode",
	"\r\nset_dummy_task_params_operation_mode [dum] [op_mod]\r\n"
	" Sets the operation mode of the dummy task.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a string that specifies the operation mode.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_OP_MOD "\r\n"
	"\r\n",
	set_dummy_task_params_operation_mode_func,
	2
};

static const CLI_Command_Definition_t set_dummy_task_params_memory_struct = {
	"set_dummy_task_params_memory",
	"\r\nset_dummy_task_params_memory [dum] [mem]\r\n"
	" Sets the operation mode of the dummy task.\n\r"
	" The first argument is string that specifies the dummy task, whereas the next is a string that specifies the operation mode.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	HELP_CMD_PARAM_MEM "\r\n"
	"\r\n",
	set_dummy_task_params_memory_func,
	2
};

static const CLI_Command_Definition_t get_dummy_task_report_struct = {
	"get_dummy_task_report",
	"\r\nget_dummy_task_report [dum]\r\n"
	" Gets the report for the specified dummy task.\n\r"
	" The argument is a boolean value that specifies the dummy task.\r\n"
	HELP_CMD_PARAM_DUM "\r\n"
	"\r\n",
	get_dummy_task_report_func,
	1
};

void commandline_setup() {

	/* Clear flags. */
	status_obj.is_json = 0;
	status_obj.configure_cpu1_flag = 0;
	status_obj.capture_write_to_buffer_flag = 0;

	/* Register the commands. */
	FreeRTOS_CLIRegisterCommand(&set_json_struct);
	FreeRTOS_CLIRegisterCommand(&set_configure_cpu1_struct);
	FreeRTOS_CLIRegisterCommand(&set_configure_smp_struct);
	FreeRTOS_CLIRegisterCommand(&request_opteration_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_enable_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_location_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_params_burst_len_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_params_transfer_size_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_params_memory_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_params_operation_mode_struct);
	FreeRTOS_CLIRegisterCommand(&set_hardware_cache_coherent_struct);
	FreeRTOS_CLIRegisterCommand(&get_hardware_report_struct);
	FreeRTOS_CLIRegisterCommand(&set_memory_policies_struct);
	FreeRTOS_CLIRegisterCommand(&set_memory_transfer_size_struct);
	FreeRTOS_CLIRegisterCommand(&get_memory_report_struct);
	FreeRTOS_CLIRegisterCommand(&get_hard_report_struct);
	FreeRTOS_CLIRegisterCommand(&get_synch_report_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_enable_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_identifier_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_location_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_powersave_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_burst_len_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_transfer_size_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_operation_mode_struct);
	FreeRTOS_CLIRegisterCommand(&set_dummy_task_params_memory_struct);
	FreeRTOS_CLIRegisterCommand(&get_dummy_task_report_struct);

	/* Start the console thread. */
	vUARTCommandConsoleStart(TASK_DEFAULT_SIZE,tskIDLE_PRIORITY);

}

portBASE_TYPE	set_json_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int is_json_flag;
	int result = 0;
	char* is_json_flag_as_string = get_parameter(pcCommandString,1);

	is_json_flag = (is_integer(is_json_flag_as_string))?atoi(is_json_flag_as_string):-1;
	if (is_json_flag>=0) {
		result = 1;
		status_obj.is_json = (is_json_flag!=0);
		pcCmdCharsFlag = pcEchoFlag = (is_json_flag==0);
	}
	free(is_json_flag_as_string);
	set_status(pcWriteBuffer,xWriteBufferLen,result);
	return pdFALSE;
}

portBASE_TYPE	set_configure_cpu1_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int configure_cpu1_flag;
	int result = 0;
	char* configure_cpu1_flag_as_string = get_parameter(pcCommandString,1);

	configure_cpu1_flag = (is_integer(configure_cpu1_flag_as_string))?atoi(configure_cpu1_flag_as_string):-1;
	if (configure_cpu1_flag>=0) {
		result = 1;
		status_obj.configure_cpu1_flag = (configure_cpu1_flag!=0);
	}
	free(configure_cpu1_flag_as_string);
	set_status(pcWriteBuffer,xWriteBufferLen,result);
	return pdFALSE;
}

portBASE_TYPE set_configure_smp_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int is_smp_flag;
	int result = 0;
	char* is_smp_flag_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {

		is_smp_flag_as_string = get_parameter(pcCommandString,1);
		is_smp_flag = (is_integer(is_smp_flag_as_string))?atoi(is_smp_flag_as_string):-1;

		if (is_smp_flag>=0) {
#warning CPU_WARNING_ADDED
		}

		free(is_smp_flag_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE request_operation_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {
	set_status(pcWriteBuffer,xWriteBufferLen,main_request_operation());
	return pdFALSE;
}

portBASE_TYPE set_hardware_enable_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int is_enabled_flag;
	int result = 0;
	char* hardware_identifier_as_string	= get_parameter(pcCommandString,1);
	char* is_enabled_flag_as_string		= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	is_enabled_flag = (is_integer(is_enabled_flag_as_string))?atoi(is_enabled_flag_as_string):-1;

	if ((hardware_identifier>=0)&&(is_enabled_flag>=0)) {
		result = Main_set_hardware_enable(hardware_identifier,is_enabled_flag);
	}

	free(hardware_identifier_as_string);
	free(is_enabled_flag_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_location_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int location;
	int result = 0;
	char* hardware_identifier_as_string	= get_parameter(pcCommandString,1);
	char* location_as_string			= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	location = (is_integer(location_as_string))?atoi(location_as_string):-1;

	if ((hardware_identifier>=0)&&(location>=0)) {
		result = Main_set_hardware_location(hardware_identifier,location);
	}

	free(hardware_identifier_as_string);
	free(location_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_params_burst_len_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int burst_len;
	int result = 0;
	char* hardware_identifier_as_string	= get_parameter(pcCommandString,1);
	char* burst_len_as_string			= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	burst_len = (is_integer(burst_len_as_string))?atoi(burst_len_as_string):-1;

	if ((hardware_identifier>=0)&&(burst_len>=0)) {
		result = Main_set_hardware_params_burst_len(hardware_identifier,burst_len);
	}

	free(hardware_identifier_as_string);
	free(burst_len_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_params_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int transfer_size;
	int result = 0;
	char* hardware_identifier_as_string		= get_parameter(pcCommandString,1);
	char* transfer_size_as_string			= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	transfer_size = (is_integer(transfer_size_as_string))?atoi(transfer_size_as_string):-1;

	if ((hardware_identifier>=0)&&(transfer_size>=0)) {
		result = Main_set_hardware_params_transfer_size(hardware_identifier,transfer_size);
	}

	free(hardware_identifier_as_string);
	free(transfer_size_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_params_params_operation_mode_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int operation_mode_identifier;
	int result = 0;
	char* hardware_identifier_as_string			= get_parameter(pcCommandString,1);
	char* operation_mode_identifier_as_string	= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	operation_mode_identifier = get_operation_mode_identifier(operation_mode_identifier_as_string);

	if ((hardware_identifier>=0)&&(operation_mode_identifier>=0)) {
		result = Main_set_hardware_params_operation_mode(hardware_identifier,operation_mode_identifier);
	}

	free(hardware_identifier_as_string);
	free(operation_mode_identifier_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_params_memory_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int memory_identifier;
	int result = 0;
	char* hardware_identifier_as_string			= get_parameter(pcCommandString,1);
	char* memory_identifier_as_string			= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	memory_identifier = Main_get_memory_identifier(memory_identifier_as_string);

	if ((hardware_identifier>=0)&&(memory_identifier>=0)) {
		result = Main_set_hardware_params_memory(hardware_identifier,memory_identifier);
	}

	free(hardware_identifier_as_string);
	free(memory_identifier_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_hardware_cache_coherent_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int is_cache_coherent_flag;
	int result = 0;
	char* hardware_identifier_as_string			= get_parameter(pcCommandString,1);
	char* is_cache_coherent_flag_as_string		= get_parameter(pcCommandString,2);

	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	is_cache_coherent_flag = (is_integer(is_cache_coherent_flag_as_string))?atoi(is_cache_coherent_flag_as_string):-1;

	if ((hardware_identifier>=0)&&(is_cache_coherent_flag>=0)) {
		result = Main_set_hardware_cache_coherent(hardware_identifier,is_cache_coherent_flag);
	}

	free(hardware_identifier_as_string);
	free(is_cache_coherent_flag_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE get_hardware_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int hardware_identifier;
	int result = 0;
	size_t report_size;
	char* hardware_identifier_as_string;
	const Hardware* hde_obj;

	hardware_identifier_as_string = get_parameter(pcCommandString,1);
	hardware_identifier = Main_get_hardware_identifier(hardware_identifier_as_string);
	hde_obj = Main_get_hardware(hardware_identifier);
	if (hde_obj != NULL) {
		result = 1;
		status_obj.capture_write_to_buffer_flag = 1;
		Cli_Hardware_send_report(hde_obj);
		status_obj.capture_write_to_buffer_flag = 0;
		set_report(pcWriteBuffer,xWriteBufferLen);
		report_size = strlen(pcWriteBuffer);
		pcWriteBuffer += report_size;
		xWriteBufferLen -= report_size;
	}

	free(hardware_identifier_as_string);

	set_status(pcWriteBuffer,xWriteBufferLen,result);

	return pdFALSE;
}

portBASE_TYPE set_memory_policies_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int memory_identifier;
	int policy_0_identifier;
	int policy_1_identifier;
	int result = 0;
	char* memory_identifier_as_string;
	char* policy_0_as_string;
	char* policy_1_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		memory_identifier_as_string			= get_parameter(pcCommandString,1);
		policy_0_as_string					= get_parameter(pcCommandString,2);
		policy_1_as_string					= get_parameter(pcCommandString,3);

		memory_identifier = Main_get_memory_identifier(memory_identifier_as_string);
		policy_0_identifier = get_cache_policy_identifier(policy_0_as_string);
		policy_1_identifier = get_cache_policy_identifier(policy_1_as_string);

		if ((memory_identifier>=0)&&(policy_0_identifier>=0)&&(policy_1_identifier>=0)) {
			result = Main_set_memory_policies(memory_identifier,policy_0_identifier,policy_1_identifier);
		}

		free(memory_identifier_as_string);
		free(policy_0_as_string);
		free(policy_1_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_memory_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int memory_identifier;
	int transfer_size;
	int result = 0;
	char* memory_identifier_as_string;
	char* transfer_size_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		memory_identifier_as_string 			= get_parameter(pcCommandString,1);
		transfer_size_as_string					= get_parameter(pcCommandString,2);

		memory_identifier = Main_get_memory_identifier(memory_identifier_as_string);
		transfer_size = (is_integer(transfer_size_as_string))?atoi(transfer_size_as_string):-1;

		if ((memory_identifier>=0)&&(transfer_size>=0)) {
			result = Main_set_memory_transfer_size(memory_identifier,transfer_size);
		}

		free(memory_identifier_as_string);
		free(transfer_size_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE get_memory_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int memory_identifier;
	int result = 0;
	size_t report_size;
	char* memory_identifier_as_string;
	const Memory* mry_obj;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		memory_identifier_as_string = get_parameter(pcCommandString,1);
		memory_identifier = Main_get_memory_identifier(memory_identifier_as_string);
		mry_obj = Main_get_memory(memory_identifier);
		if (mry_obj != NULL) {
			result = 1;
			status_obj.capture_write_to_buffer_flag = 1;
			Cli_Memory_send_report(mry_obj);
			status_obj.capture_write_to_buffer_flag = 0;
			set_report(pcWriteBuffer,xWriteBufferLen);
			report_size = strlen(pcWriteBuffer);
			pcWriteBuffer += report_size;
			xWriteBufferLen -= report_size;
		}

		free(memory_identifier_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE get_hard_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int current_size;
	set_hard_report(pcWriteBuffer,xWriteBufferLen);
	current_size = strlen(pcWriteBuffer);
	set_status(pcWriteBuffer+current_size,xWriteBufferLen-current_size,0);
	return pdFALSE;
}

static portBASE_TYPE get_synch_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int result = 0;
	size_t report_size;
	const Synch* syn_obj;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		syn_obj = Main_get_synch();
		if (syn_obj != NULL) {
			result = 1;
			status_obj.capture_write_to_buffer_flag = 1;
			Cli_Synch_send_report(syn_obj);
			status_obj.capture_write_to_buffer_flag = 0;
			set_report(pcWriteBuffer,xWriteBufferLen);
			report_size = strlen(pcWriteBuffer);
			pcWriteBuffer += report_size;
			xWriteBufferLen -= report_size;
		}

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_enable_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int is_enabled_flag;
	int dummy_task_identifier;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* is_enabled_flag_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  		= get_parameter(pcCommandString,1);
		is_enabled_flag_as_string				= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		is_enabled_flag = (is_integer(is_enabled_flag_as_string))?atoi(is_enabled_flag_as_string):-1;

		if ((dummy_task_identifier>=0)&&(is_enabled_flag>=0)) {
			result = Main_set_dummy_task_enable(dummy_task_identifier,is_enabled_flag);
		}

		free(dummy_task_identifier_as_string);
		free(is_enabled_flag_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_identifier_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int identifier;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* identifier_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  	= get_parameter(pcCommandString,1);
		identifier_as_string				= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		identifier = (is_integer(identifier_as_string))?atoi(identifier_as_string):-1;

		if ((dummy_task_identifier>=0)&&(identifier>=0)) {
			result = Main_set_dummy_task_identifier(dummy_task_identifier,identifier);
		}

		free(dummy_task_identifier_as_string);
		free(identifier_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_location_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int location;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* location_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  	= get_parameter(pcCommandString,1);
		location_as_string					= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		location = (is_integer(location_as_string))?atoi(location_as_string):-1;

		if ((dummy_task_identifier>=0)&&(location>=0)) {
			result = Main_set_dummy_task_location(dummy_task_identifier,location);
		}

		free(dummy_task_identifier_as_string);
		free(location_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_powersave_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int is_powersave_flag;
	int dummy_task_identifier;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* is_powersave_flag_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  		= get_parameter(pcCommandString,1);
		is_powersave_flag_as_string				= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		is_powersave_flag = (is_integer(is_powersave_flag_as_string))?atoi(is_powersave_flag_as_string):-1;

		if ((dummy_task_identifier>=0)&&(is_powersave_flag>=0)) {
			result = Main_set_dummy_task_powersave(dummy_task_identifier,is_powersave_flag);
		}

		free(dummy_task_identifier_as_string);
		free(is_powersave_flag_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_params_burst_len_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int burst_len;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* burst_len_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  	= get_parameter(pcCommandString,1);
		burst_len_as_string					= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		burst_len = (is_integer(burst_len_as_string))?atoi(burst_len_as_string):-1;

		if ((dummy_task_identifier>=0)&&(burst_len>=0)) {
			result = Main_set_dummy_task_params_burst_len(dummy_task_identifier,burst_len);
		}

		free(dummy_task_identifier_as_string);
		free(burst_len_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_params_transfer_size_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int transfer_size;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* transfer_size_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  	= get_parameter(pcCommandString,1);
		transfer_size_as_string				= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		transfer_size = (is_integer(transfer_size_as_string))?atoi(transfer_size_as_string):-1;

		if ((dummy_task_identifier>=0)&&(transfer_size>=0)) {
			result = Main_set_dummy_task_params_transfer_size(dummy_task_identifier,transfer_size);
		}

		free(dummy_task_identifier_as_string);
		free(transfer_size_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_params_operation_mode_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int operation_mode_identifier;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* operation_mode_identifier_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string			= get_parameter(pcCommandString,1);
		operation_mode_identifier_as_string		= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		operation_mode_identifier = get_operation_mode_identifier(operation_mode_identifier_as_string);

		if ((dummy_task_identifier>=0)&&(operation_mode_identifier>=0)) {
			result = Main_set_dummy_task_params_operation_mode(dummy_task_identifier,operation_mode_identifier);
		}

		free(dummy_task_identifier_as_string);
		free(operation_mode_identifier_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE set_dummy_task_params_memory_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int memory_identifier;
	int result = 0;
	char* dummy_task_identifier_as_string;
	char* memory_identifier_as_string;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string  	= get_parameter(pcCommandString,1);
		memory_identifier_as_string			= get_parameter(pcCommandString,2);

		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		memory_identifier = Main_get_memory_identifier(memory_identifier_as_string);

		if ((dummy_task_identifier>=0)&&(memory_identifier>=0)) {
			result = Main_set_dummy_task_params_memory(dummy_task_identifier,memory_identifier);
		}

		free(dummy_task_identifier_as_string);
		free(memory_identifier_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

portBASE_TYPE get_dummy_task_report_func(char *pcWriteBuffer,size_t xWriteBufferLen,const char *pcCommandString) {

	int dummy_task_identifier;
	int result = 0;
	size_t report_size;
	char* dummy_task_identifier_as_string;
	const Dummy_Task* dmy_obj;

	if (status_obj.configure_cpu1_flag) {
#if (CPU_DISABLE==0)
		Shared_forward_command(shd_obj,pcCommandString,pcWriteBuffer,xWriteBufferLen);
#else
		set_status(pcWriteBuffer,xWriteBufferLen,1);
#endif
	} else {
		dummy_task_identifier_as_string = get_parameter(pcCommandString,1);
		dummy_task_identifier = Main_get_dummy_task_identifier(dummy_task_identifier_as_string);
		dmy_obj = Main_get_dummy_task(dummy_task_identifier);
		if (dmy_obj != NULL) {
			result = 1;
			status_obj.capture_write_to_buffer_flag = 1;
			Cli_Dummy_Task_send_report(dmy_obj);
			status_obj.capture_write_to_buffer_flag = 0;
			set_report(pcWriteBuffer,xWriteBufferLen);
			report_size = strlen(pcWriteBuffer);
			pcWriteBuffer += report_size;
			xWriteBufferLen -= report_size;
		}

		free(dummy_task_identifier_as_string);

		set_status(pcWriteBuffer,xWriteBufferLen,result);
	}

	return pdFALSE;
}

char* get_parameter(const char *pcCommandString, int parameter_position) {

	portBASE_TYPE paramsize;
	char* param;
	char* buffer;

	// Acquire the parameter
	param = (char*)FreeRTOS_CLIGetParameter(pcCommandString, parameter_position, &paramsize);
	buffer = malloc(paramsize+1);
	memcpy(buffer, param, paramsize);
	buffer[paramsize] = '\0';

	return buffer;
}

int is_integer(char* nullTerminatedString) {
	for (; *nullTerminatedString; nullTerminatedString++)
		if (!(*nullTerminatedString == '-' ||
				*nullTerminatedString == '+' ||
				isdigit((int)*nullTerminatedString)))
			return 0;
	return 1;
}

void set_status(char* pcWriteBuffer,size_t xWriteBufferLen,int is_success_flag) {
	char buffer[BUFFER_SIZE];
	char* result = (is_success_flag)?"succeeded":"failed";
	sprintf(buffer,(status_obj.is_json)?
			"{\"type\":\"status\",\"status\":\"%s\"}":
			"Status             :\t%s\n\r",result);
	Xil_AssertVoid(strlen(buffer)<xWriteBufferLen);
	strcpy(pcWriteBuffer,buffer);
}
